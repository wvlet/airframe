/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package wvlet.airframe.http.codegen
import java.util.Locale

import wvlet.airframe.http.Router
import wvlet.airframe.http.codegen.HttpClientIR._
import wvlet.log.LogSupport

/**
  * Genearate HTTP client code for Scala, Scala.js targets using a given IR
  */
object HttpClientGenerator extends LogSupport {

  def generate(
      router: Router,
      target: String,
      config: HttpClientGeneratorConfig = HttpClientGeneratorConfig()
  ): String = {
    val ir = HttpClientIR.buildIR(router, config)
    val code = target match {
      case "AsyncClient" => generateAsyncClient(ir)
      case "SyncClient"  => generateSyncClient(ir)
      case "ScalaJS"     => generateScalaJSClient(ir)
    }
    debug(code)
    code
  }

  private def header(packageName: String): String = {
    s"""/**
       | * === DO NOT EDIT THIS FILE ===
       | * This code is generated by sbt-airframe plugin.
       | */
       |package ${packageName}""".stripMargin
  }

  private def indent(body: String, level: Int = 1): String = {
    body
      .split("\n").map { x => s"${"  " * level}${x}" }
      .mkString("\n")
  }

  def generateAsyncClient(src: ClientSourceDef): String = {
    def code =
      s"""${header(src.packageName)}
         |
         |import wvlet.airframe.http._
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""class ${src.classDef.clsName}[F[_], Req, Resp](private val client: HttpClient[F, Req, Resp]) extends AutoCloseable {
         |  override def close(): Unit = { client.close() }
         |  def getClient: HttpClient[F, Req, Resp] = client
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs =
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++ Seq("requestFilter: Req => Req = identity")

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""resourcePath = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs += "requestFilter = requestFilter"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): F[${m.returnType.name}] = {
             |  client.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code
  }

  def generateSyncClient(src: ClientSourceDef): String = {
    def code =
      s"""${header(src.packageName)}
         |
         |import wvlet.airframe.http._
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""class ${src.classDef.clsName}[Req, Resp](private val client: HttpSyncClient[Req, Resp]) extends AutoCloseable {
         |  override def close(): Unit = { client.close() }
         |  def getClient: HttpSyncClient[Req, Resp] = client
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs =
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++ Seq("requestFilter: Req => Req = identity")

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""resourcePath = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs += "requestFilter = requestFilter"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): ${m.returnType.name} = {
             |  client.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code
  }

  def generateScalaJSClient(src: ClientSourceDef): String = {
    def code =
      s"""${header(src.packageName)}
         |
         |import scala.concurrent.Future
         |import wvlet.airframe.surface.Surface
         |import wvlet.airframe.http.js.HttpClient
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""object ${src.classDef.clsName} {
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs = {
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++
              Seq("headers: Map[String, String] = Map.empty")
          }

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""path = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs ++= m.typeArgs.map(s => s"Surface.of[${s.name}]")
          sendRequestArgs += "headers = headers"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): Future[${m.returnType.name}] = {
             |  HttpClient.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code
  }
}
