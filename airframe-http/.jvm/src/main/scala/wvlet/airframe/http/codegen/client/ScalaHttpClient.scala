/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package wvlet.airframe.http.codegen.client
import java.util.Locale

import wvlet.airframe.http.codegen.HttpClientIR.{ClientServiceDef, ClientSourceDef}

/**
  *
  */
object ScalaHttpClient {
  def header(packageName: String): String = {
    s"""/**
       | * === DO NOT EDIT THIS FILE ===
       | * This code is generated by sbt-airframe plugin.
       | */
       |package ${packageName}""".stripMargin
  }

  def indent(body: String, level: Int = 1): String = {
    body
      .split("\n").map { x => s"${"  " * level}${x}" }
      .mkString("\n")
  }
}

import ScalaHttpClient._

object AsyncClient extends HttpClientType {
  override def name: String             = "async"
  override def defaultFileName: String  = "ServiceClient.scala"
  override def defaultClassName: String = "ServiceClient"
  override def generate(src: ClientSourceDef): String = {
    def code = s"""${header(src.packageName)}
         |
         |import wvlet.airframe.http._
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""class ${src.classDef.clsName}[F[_], Req, Resp](private val client: HttpClient[F, Req, Resp]) extends AutoCloseable {
         |  override def close(): Unit = { client.close() }
         |  def getClient: HttpClient[F, Req, Resp] = client
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs =
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++ Seq("requestFilter: Req => Req = identity")

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""resourcePath = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs += "requestFilter = requestFilter"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): F[${m.returnType.name}] = {
             |  client.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code
  }
}

object SyncClient extends HttpClientType {
  override def name: String             = "sync"
  override def defaultFileName: String  = "ServiceSyncClient.scala"
  override def defaultClassName: String = "ServiceSyncClient"
  override def generate(src: ClientSourceDef): String = {
    def code =
      s"""${header(src.packageName)}
         |
         |import wvlet.airframe.http._
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""class ${src.classDef.clsName}[Req, Resp](private val client: HttpSyncClient[Req, Resp]) extends AutoCloseable {
         |  override def close(): Unit = { client.close() }
         |  def getClient: HttpSyncClient[Req, Resp] = client
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs =
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++ Seq("requestFilter: Req => Req = identity")

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""resourcePath = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs += "requestFilter = requestFilter"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): ${m.returnType.name} = {
             |  client.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code

  }
}

/**
  *
  */
object ScalaJSClient extends HttpClientType {
  override def name: String             = "scalajs"
  override def defaultFileName: String  = "ServiceJSClient.scala"
  override def defaultClassName: String = "ServiceJSClient"
  override def generate(src: ClientSourceDef): String = {
    def code =
      s"""${header(src.packageName)}
         |
         |import scala.concurrent.Future
         |import wvlet.airframe.surface.Surface
         |import wvlet.airframe.http.js.JSHttpClient
         |import wvlet.airframe.http.HttpMessage.Request
         |${src.imports.map(x => s"import ${x.rawType.getName}").mkString("\n")}
         |
         |${cls}""".stripMargin

    def cls: String =
      s"""class ${src.classDef.clsName}(private val client: JSHttpClient = JSHttpClient.defaultClient) {
         |  def getClient: JSHttpClient = client
         |
         |${indent(clsBody)}
         |}
         |""".stripMargin

    def clsBody: String = {
      src.classDef.services
        .map { svc =>
          s"""object ${svc.serviceName} {
             |${indent(serviceBody(svc))}
             |}""".stripMargin
        }.mkString("\n")
    }

    def serviceBody(svc: ClientServiceDef): String = {
      svc.methods
        .map { m =>
          val httpMethodName       = m.httpMethod.toString.toLowerCase(Locale.ENGLISH)
          val httpClientMethodName = if (m.isOpsRequest) s"${httpMethodName}Ops" else httpMethodName

          val inputArgs = {
            m.inputParameters.map(x => s"${x.name}: ${x.surface.name}") ++
              Seq("requestFilter: Request => Request = identity")
          }

          val sendRequestArgs = Seq.newBuilder[String]
          sendRequestArgs += s"""resourcePath = s"${m.path}""""
          sendRequestArgs ++= m.clientCallParameters.map(x => s"${x.name}")
          sendRequestArgs ++= m.typeArgs.map(s => s"Surface.of[${s.name}]")
          sendRequestArgs += "requestFilter = requestFilter"

          s"""def ${m.name}(${inputArgs.mkString(", ")}): Future[${m.returnType.name}] = {
             |  client.${httpClientMethodName}[${m.typeArgs.map(_.name).mkString(", ")}](${sendRequestArgs.result
               .mkString(", ")})
             |}""".stripMargin
        }.mkString("\n")
    }

    code
  }
}
